/* -------------------------------------------------------------------------+
 |                               DiNiTo Ltd.                                |
 + -------------------------------------------------------------------------*/

/* --------------------------- COPYRIGHT INFORMATION -----------------------+
 |                                                                          |
 |                                                                          |
 |                                                                          |
 |                                                                          |
 + -------------------------------------------------------------------------*/


/******************************************************************************
 * @file     system_RA6M3.c
 * @brief    CMSIS Device System Source File for Renesas RA6M3 Device Series
 * @version  V1.00
 * @date     10 Mar 2017
 *
 * @note
 *
 ******************************************************************************/

#define  __SYSTEM_RA6M3_C__ 0x0100

/* -------------------------------------------------------------------------+
 |   HEADER (INCLUDE) SECTION                                               |
 + -------------------------------------------------------------------------*/
#include <string.h>
#include "bsp_api.h"
//#include "RA6_Init.h"
//#include "mbed_drv_cfg.h"


/* -------------------------------------------------------------------------+
 |   EXTERNAL DATA (+ meaning)                                              |
 + -------------------------------------------------------------------------*/

#if defined(__ARMCC_VERSION)
extern uint32_t Image$$RW_IRAM1$$Base;
extern uint32_t Image$$RW_IRAM1$$Length;
extern uint32_t Load$$DATA$$Base;
extern uint32_t Image$$DATA$$Base;
extern uint32_t Image$$DATA$$Length;
extern uint32_t Image$$ARM_LIB_STACK$$ZI$$Base;
extern uint32_t Image$$ARM_LIB_STACK$$ZI$$Length;
#elif defined(__GNUC__)

/* Generated by linker. */
extern uint32_t __etext;
extern uint32_t __data_start__;
extern uint32_t __data_end__;
extern uint32_t __bss_start__;
extern uint32_t __bss_end__;
extern uint32_t __StackLimit;
extern uint32_t __StackTop;
#elif defined(__ICCARM__)
 #pragma section=".bss"
 #pragma section=".data"
 #pragma section=".data_init"
 #pragma section=".stack"
#endif

/* Initialize static constructors */
#if defined(__ARMCC_VERSION)
extern void (* Image$$INIT_ARRAY$$Base[])(void);
extern void (* Image$$INIT_ARRAY$$Limit[])(void);
#elif defined(__GNUC__)

extern void (* __init_array_start[])(void);

extern void (* __init_array_end[])(void);
#elif defined(__ICCARM__)
extern void __call_ctors(void const *, void const *);

 #pragma section = "SHT$$PREINIT_ARRAY" const
 #pragma section = "SHT$$INIT_ARRAY" const
#endif

extern void * __Vectors[];

/* -------------------------------------------------------------------------+
 |   MACROS                                                                 |
 + -------------------------------------------------------------------------*/

 /* Mask to select CP bits( 0xF00000 ) */
#define CP_MASK                             (0xFU << 20)
 /* Set bits 20-23 (CP10 and CP11) to enable FPU. */
#define __FPU_Enable()                      SCB->CPACR = (uint32_t) CP_MASK

/* Value to write to OAD register of MPU stack monitor to enable NMI when a stack overflow is detected. */
#define BSP_STACK_POINTER_MONITOR_NMI_ON_DETECTION    (0xA500U)

/* Key code for writing PRCR register. */
#define BSP_PRV_PRCR_KEY                              (0xA500U)
#define BSP_PRV_PRCR_PRC1_UNLOCK                      ((BSP_PRV_PRCR_KEY) | 0x2U)
#define BSP_PRV_PRCR_LOCK                             ((BSP_PRV_PRCR_KEY) | 0x0U)

#if defined(__ICCARM__)
 #define BSP_PRV_STACK_LIMIT                          ((uint32_t) __section_begin(".stack"))
 #define BSP_PRV_STACK_TOP                            ((uint32_t) __section_end(".stack"))
#elif defined(__ARMCC_VERSION)
 #define BSP_PRV_STACK_LIMIT                          ((uint32_t) &Image$$ARM_LIB_STACK$$ZI$$Base)
 #define BSP_PRV_STACK_TOP                            ((uint32_t) &Image$$ARM_LIB_STACK$$ZI$$Base + \
                                                       (uint32_t) &Image$$ARM_LIB_STACK$$ZI$$Length)
#elif defined(__GNUC__)
 #define BSP_PRV_STACK_LIMIT                          ((uint32_t) &__StackLimit)
 #define BSP_PRV_STACK_TOP                            ((uint32_t) &__StackTop)
#endif

#define BSP_TZ_STACK_SEAL_VALUE                       (0xFEF5EDA5)

#define BSP_CORTEX_VECTOR_TABLE_ENTRIES    (16U)
#define BSP_VECTOR_TABLE_MAX_ENTRIES       (112U)
#define BSP_ICU_VECTOR_MAX_ENTRIES    (BSP_VECTOR_TABLE_MAX_ENTRIES - BSP_CORTEX_VECTOR_TABLE_ENTRIES)

/* -------------------------------------------------------------------------+
 |   TYPE DEFINITIONS                                                       |
 + -------------------------------------------------------------------------*/

/* none */
 
/* -------------------------------------------------------------------------+
 |   GLOBAL CONSTANTS                                                       |
 + -------------------------------------------------------------------------*/

/* none */

/* -------------------------------------------------------------------------+
 |   GLOBAL VARIABLES                                                       |
 + -------------------------------------------------------------------------*/

/** System Clock Frequency (Core Clock) */
uint32_t SystemCoreClock BSP_SECTION_EARLY_INIT;

/* -------------------------------------------------------------------------+
 |   LOCAL FUNCTION PROTOTYPES                                              |
 + -------------------------------------------------------------------------*/

void bsp_reset_trng_circuit(void);
static void CRunTimeInit(void);

/* -------------------------------------------------------------------------+
 |   LOCAL  VARIABLES                                                       |
 + -------------------------------------------------------------------------*/

/* none */

/* -------------------------------------------------------------------------+
 |   LOCAL FUNCTIONS                                                        |                                         
 + -------------------------------------------------------------------------*/

/* Initialize C runtime environment. */
static void CRunTimeInit(void)
{
    /* Zero out BSS */
 #if defined(__ARMCC_VERSION)
    memset((uint8_t *) &Image$$RW_IRAM1$$Base, 0U, (uint32_t) &Image$$RW_IRAM1$$Length);
 #elif defined(__GNUC__)
    memset(&__bss_start__, 0U, ((uint32_t) &__bss_end__ - (uint32_t) &__bss_start__));
 #elif defined(__ICCARM__)
    memset((uint32_t *) __section_begin(".bss"), 0U, (uint32_t) __section_size(".bss"));
 #endif

    /* Copy initialized RAM data from ROM to RAM. */
 #if defined(__ARMCC_VERSION)
    memcpy((uint8_t *) &Image$$DATA$$Base, (uint8_t *) &Load$$DATA$$Base, (uint32_t) &Image$$DATA$$Length);
 #elif defined(__GNUC__)
    memcpy(&__data_start__, &__etext, ((uint32_t) &__data_end__ - (uint32_t) &__data_start__));
 #elif defined(__ICCARM__)
    memcpy((uint32_t *) __section_begin(".data"), (uint32_t *) __section_begin(".data_init"),
           (uint32_t) __section_size(".data"));

    /* Copy functions to be executed from RAM. */
  #pragma section=".code_in_ram"
  #pragma section=".code_in_ram_init"
    memcpy((uint32_t *) __section_begin(".code_in_ram"),
           (uint32_t *) __section_begin(".code_in_ram_init"),
           (uint32_t) __section_size(".code_in_ram"));

    /* Copy main thread TLS to RAM. */
  #pragma section="__DLIB_PERTHREAD_init"
  #pragma section="__DLIB_PERTHREAD"
    memcpy((uint32_t *) __section_begin("__DLIB_PERTHREAD"), (uint32_t *) __section_begin("__DLIB_PERTHREAD_init"),
           (uint32_t) __section_size("__DLIB_PERTHREAD_init"));
 #endif

    /* Initialize static constructors */
 #if defined(__ARMCC_VERSION)
    int32_t count = Image$$INIT_ARRAY$$Limit - Image$$INIT_ARRAY$$Base;
    for (int32_t i = 0; i < count; i++)
    {
        void (* p_init_func)(void) =
            (void (*)(void))((uint32_t) &Image$$INIT_ARRAY$$Base + (uint32_t) Image$$INIT_ARRAY$$Base[i]);
        p_init_func();
    }

 #elif defined(__GNUC__)
    int32_t count = __init_array_end - __init_array_start;
    for (int32_t i = 0; i < count; i++)
    {
        __init_array_start[i]();
    }

 #elif defined(__ICCARM__)
    void const * pibase = __section_begin("SHT$$PREINIT_ARRAY");
    void const * ilimit = __section_end("SHT$$INIT_ARRAY");
    __call_ctors(pibase, ilimit);
 #endif                                 
}


/* -------------------------------------------------------------------------+
 |   GLOBAL FUNCTIONS                                                       |
 + -------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------
  System Initialization & Runtime Environment
 *----------------------------------------------------------------------------*/
void SystemInit (void)
{
/*       do not use global variables because this function is called before
         reaching pre-main. RW section may be overwritten afterwards.          */
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
    /* Enable the FPU only when it is used.
     * Code taken from Section 7.1, Cortex-M4 TRM (DDI0439C) */

    /* Set bits 20-23 (CP10 and CP11) to enable FPU. */
    __FPU_Enable();
#endif

    /* VTOR is in undefined state out of RESET:
    * https://developer.arm.com/documentation/100235/0004/the-cortex-m33-peripherals/system-control-block/system-control-block-registers-summary?lang=en.
    * Set the Secure/Non-Secure VTOR to the vector table address based on the build. This is skipped for non-secure
    * projects because SCB_NS->VTOR is set by the secure project before the non-secure project runs. */
    SCB->VTOR = (uint32_t) &__Vectors;

#if !BSP_TZ_CFG_SKIP_INIT
 #if BSP_FEATURE_BSP_VBATT_HAS_VBTCR1_BPWSWSTP

    /* Unlock VBTCR1 register. */
    R_SYSTEM->PRCR = (uint16_t) BSP_PRV_PRCR_PRC1_UNLOCK;

    /* The VBTCR1.BPWSWSTP must be set after reset on MCUs that have VBTCR1.BPWSWSTP. Reference section 11.2.1
     * "VBATT Control Register 1 (VBTCR1)" and Figure 11.2 "Setting flow of the VBTCR1.BPWSWSTP bit" in the RA4M1 manual
     * R01UM0007EU0110. This must be done before bsp_clock_init because LOCOCR, LOCOUTCR, SOSCCR, and SOMCR cannot
     * be accessed until VBTSR.VBTRVLD is set. */
    R_SYSTEM->VBTCR1 = 1U;
    FSP_HARDWARE_REGISTER_WAIT(R_SYSTEM->VBTSR_b.VBTRVLD, 1U);

    /* Lock VBTCR1 register. */
    R_SYSTEM->PRCR = (uint16_t) BSP_PRV_PRCR_LOCK;
 #endif
#endif
#if BSP_CFG_EARLY_INIT

    /* Initialize uninitialized BSP variables early for use in R_BSP_WarmStart. */
    bsp_init_uninitialized_vars();
#endif

    /* Configure system clocks. */
    bsp_clock_init();

#if BSP_FEATURE_BSP_HAS_SP_MON
    /* Disable MSP monitoring  */
    R_MPU_SPMON->SP[0].CTL = 0;

    /* Setup NMI interrupt  */
    R_MPU_SPMON->SP[0].OAD = BSP_STACK_POINTER_MONITOR_NMI_ON_DETECTION;

    /* Setup start address  */
    R_MPU_SPMON->SP[0].SA = BSP_PRV_STACK_LIMIT;

    /* Setup end address  */
    R_MPU_SPMON->SP[0].EA = BSP_PRV_STACK_TOP;

    /* Set SPEEN bit to enable NMI on stack monitor exception. NMIER bits cannot be cleared after reset, so no need
     * to read-modify-write. */
    R_ICU->NMIER = R_ICU_NMIER_SPEEN_Msk;

    /* Enable MSP monitoring  */
    R_MPU_SPMON->SP[0].CTL = 1U;
#endif

#if BSP_CFG_C_RUNTIME_INIT
    CRunTimeInit();
#endif

    /* Initialize SystemCoreClock variable. */
    SystemCoreClockUpdate();

    /* Initialize ELC events that will be used to trigger NVIC interrupts. */
    bsp_irq_cfg();

    /* Call any BSP specific code. No arguments are needed so NULL is sent. */
    bsp_init(NULL);



  //RA6_InitBus();
}

/* -------------------------------------------------------------------------+
 |   END                                                                    |
 + -------------------------------------------------------------------------*/

#undef __SYSTEM_RA6M3_C__




//void __FPU_Enable()
//{
//    /* Enable the FPU only when it is used.
//     * Code taken from Section 7.1, Cortex-M4 TRM (DDI0439C) */
//
//    /* Set bits 20-23 (CP10 and CP11) to enable FPU. */
//    SCB->CPACR = (uint32_t) CP_MASK;
//}
//


///*----------------------------------------------------------------------------
//  IRQ Handler Register/Unregister
// *----------------------------------------------------------------------------*/
//uint32_t InterruptHandlerRegister (IRQn_Type irq, IRQHandler handler)
//{
//    return IRQ_SetHandler(irq, handler);
//}
//
//uint32_t InterruptHandlerUnregister (IRQn_Type irq)
//{
//    return IRQ_SetHandler(irq, (IRQHandler_t)NULL);
//}



void mbed_sdk_init(void) {
    /* Initialize SystemCoreClock variable. */
    SystemCoreClockUpdate();
}

